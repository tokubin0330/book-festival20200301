= 人生がときめく自動化の魔法☆AWS CI/CD入門
皆さん、CI/CDしてますか？
今や開発において当たり前になった CI/CD。
当たり前になった反面プロジェクトアサイン時から CI/CD が組み込まれていたりで、よく理解しないまま何気なく利用している人もいるのではないかと思います。
また、新しい CI/CD ツールに載せ替えしたりすることもあるのではないかと思います。

そのような環境の人のためにこの章では、もう一度 CI/CD の基礎を学び直せるように CI/CD 基礎から初心者用の導入手順までを載せております。
お役に立てていただければ幸いです。

== CI/CDとは
CI/CD という言葉は今や IT 業界では一般的になっており、CI/CDが何を示しているのかを説明する機会が減ってきています。
またプロジェクト毎や会社毎または、個人の認識の違いで CI/CD が取りうる範囲が少し違うこともしばしばあります。
ここではなるべくそういった言葉の齟齬をなるべくなくすために CI/CD が取り扱う範囲を定義します。

 CI/CD は英語では「Continuous Integration/Continuous Delevary」日本語に訳すと「継続的インテグレーション/継続的デリバリー」といいます。

ここで 「CD にデプロイは入らないの？」と疑問に思った方のために RedHat が定義する CI/CD を参考@<fn>{redhat}にここでしっかりと言葉の定義をしていきます。

//footnote[redhat][CI/CD とは　https://www.redhat.com/ja/topics/devops/what-is-ci-cd#]

=== 継続的インテグレーション（Continuous Integration）
継続的インテグレーション（以下 CI と呼ぶ）は主に開発メンバーのための開発プロセスの自動化を意味します。
開発メンバーが開発時にバグの無いコードを継続的に開発していくために、コードの解析やコードフォーマットの準拠
Unit テストなどを開発プロセスに自動で行うように組み込むことで品質を上げつつ開発効率を上げていくことを目的とします。
#@# 参照 CI/CD全体の範囲図
CI は最終的にプロジェクトで利用している共通のレポジトリに自動で統合されるところまでを行います。
こうすることで新しいコードの変更が自動で、コミット、ビルド、テストされ、バグの含みにくい開発プロセスが実施できます。
小さい機能単位で開発し、CI を回していくことで、コードの競合が起きにくい開発体制になります。
#@# マージ日に一括マージしている図がで機能開発が終わる毎にマージしている様子がの図


=== 継続的デリバリー（Continuous Delibary）
継続的デリバリー（以下 CD と呼ぶ）は主に開発コードにバグがないか自動的にテストを行い、レポジトリにアップロードするまでの一連のプロセスの自動化を意味します。

#@# 参照 CI/CD全体の範囲図

CI の時と違う点は、CD がコードを最終的にアップロードする先が本番環境へデプロイされるために用意されたレポジトリである点です。
このレポジトリは常に本番環境がリリースできる状態のコードを保管しておくことが重要です。
また、継続的デリバリーのデリバリーが意味するところは、「本番相当の環境へデリバリーする」つまりシステムテストができる環境（ステージングと呼ばれたりする）にコードをデリバリーするところまでを指します。
したがって、その先のシステムテストに関しては CD のとりうる範囲ではありません。
システムテストを手動でテストするか自動でテストするかはプロジェクト要件次第になります。

CD は開発と運用のコミュニケーションロスを解決し、変更コードの導入作業の負担を下げることを目的としています。
本番環境へデプロイする運用者は CD によってアップロードされた最終的なソースコードが保管されているレポジトリさえ確認すれば開発者の変更コードを本番環境へデプロイすることができます。


=== 継続的デプロイメント
継続的デプロイメント（以下 CD（deployment）と呼ぶ）はズバリ、本番環境にデプロイするまでのプロセスの自動化を意味します。
つまり、開発者の変更コードが全て自動で本番環境へデプロイされることを指します。
したがって、CD（deployment）の重要な本質は本番環境へ自動デプロイするためのシステムテストや UI テストなどの一連のテスト作業の自動化プロセスにあります。
筆者もデプロイまでを完全自動化で運用しているサービスにはまだ出会ったことがありません。
CD（deployment）を実現させるには事前のシステムテストの洗い出しや、システムテストの自動化、UIテストの自動化などを入念に設計しておかなければなりません。
しかし、これらが実現できるプロダクトではサービスのフィードバックを即座にコードに反映させビルド、テスト、デプロイをスピーディーかつ安全に本番環境へデプロイすることができるようになります。
時には、変更コードを少しずつアップデートし、デプロイメントによる障害のリスクを低減させることも可能になります。

本章ではこのCD（deployment）のためのテストの自動化に関しては取り扱いません。
システムテストや、UI テストはステージ環境で手動で実施することを前提として CI/CD を解説していきます。
また、次の項からお話する「本番環境のデプロイ」に関しては CD（deployment）の本質を意味する「システムテストの自動化」の意味合いを含めず単に本番環境へデプロイするための自動化プロセスのことを指し示すこととします。

#@# 図 CI/CD全体の範囲図

最後の CD（deployment）に関してはプロジェクトや会社ごとで認識はバラバラだと思うのでここでは混乱を防ぐために上記のような定義でお話していきます。

CI/CD を設計する上で大切なのは CI/CD はプロジェクトによってその自動化プロセスを自由に定義し、どこまで自動化するかを決めることができることです。
開発効率を高めるためにプロジェクトの規模と期間にあった自動化プロセスの定義をプロジェクト毎に都度設計していく必要があります。
本章ではそのような環境に置かれている開発者のお手伝いとなれるように私が過去に関わったことのある CI/CD のプロセスの事例について紹介していきます。

== 一般的な CI/CD フロー
CI/CD はプロジェクト要件によって自動化プロセスを自由に定義できることところが魅力です。
しかし、初めて CI/CD を導入しようとしている方にとっては何をすればいいかわからないかもしれません。
ここでは CI/CD 入門ということでどのようなプロジェクトでも利用できる一般的な CI/CD フローを解説します。
CI/CD では@<strong>{各フローで実行される処理}のことを@<strong>{「ジョブ」}と呼びます。


=== プルリク/マージリクエスト
CI/CD の旅はここから始まります。
多くのプロジェクトは GitFow や GitHub Flow に従った Gitのブランチ戦略をとってるかと思います。
その場合新規機能を Feature ブランチで開発した後、共通レポジトリにプルリク/マージリクエストを送るはずです。
このプルリク/マージリクエストイベントをトリガーにジョブを順番に実行していきます。

=== コードの静的解析
先程のプルリク/マージリクエストイベントを検知するとコードの静的解析を行います。
例えば、javascript を利用している場合は適切な EcmaScript のバージョンで記述されているかを確認するための ESLint を実行します。
他の言語でも同様です。
いわゆる Lint を実行し、コード規約に沿っているか、推奨されるプログラムの書き方を行っているか、利用していない変数はないか、
初期化されていない変数はないか、コードエラーが出ていないかなど様々なコードやプログラム言語に関するチェックを行います。

チェックを行った後は、その結果によって後の CI を続けるか続けないかを決めます。
成功した場合は次のプロセスを実行します。
失敗した場合は失敗した旨をチャットツールなどコミュニケーションツールに知らせることもできます。

=== Unit テスト
コードの静的解析が成功すると次に Unit テストを行います。
テストコードを記述する文化がある会社やプロジェクトでは Unit テスト実行を CI 上で自動化すると良いです。
成功した場合、 Unit テストツールによってはカバレッジをログ形式で CI 上に単に表示させることができます。
また、分析しやすいように別のグラフ系の Web サービスを連携させて表示させても良いでしょう。

=== コードのマージ
Unit テストが成功すると開発用の共通ブランチにマージすることができます。
一般的にはマージ前に開発リーダや、上級エンジニアの方のコードレビューを行い、承認が通ったコードだけマージさせることが多いでしょう。
CI もそのようなフローに合わせて自動でマージさせずコードレビューのための承認フロー（マージブロック）を設定します。
マージブロックはレポジトリサービス標準で備わっている機能です。
マージリクエストに対してレビュアーをアサインさせレビュアーの承認がないとマージできないように設定することができます。


また、マージされるソースコードは、CI によってコードの規約チェックや Unit テストを行うジョブをくぐり抜けてきています。
したがって、コードレビュー者は@<strong>{「ソースコード上のビジネスロジックの確認に専念」}できます。
@<strong>{「インデントが揃ってない」}や@<strong>{「使われていない変数がある」}など、コードレビュー時の@<strong>{本質外のマージリクエストの突き返し}がなくなります。
このように CI は@<strong>{「開発者」}あるいは@<strong>{「コードレビュー者」}を@<strong>{楽にする}ための@<strong>{自動化プロセス}だと言えます。
最後に、コードレビューを行った後は「マージ」ボタンを押して開発用の共通ブランチにマージします。

ここまでが CI が取り扱うジョブの流れになります。

=== ビルド
ビルドは CD が扱うプロセスになります。プログラミング言語によっては本番環境へデプロイする前にビルドのプロセスが必要になります。
例えば、モダンな javascript 開発であれば ECMAScript7 をどんなブラウザでも動作を保証するために ECMAScript5 でトランスパイルしたり、
PHP であれば composer install でフレームワークや依存モジュールをパッケージから展開する処理をここで行います。
また、時には API のドキュメントをコメントアウトのコードから生成するようなこともあるでしょう。

要するに、ここではレポジトリのソースコードを本番環境にデプロイする準備を行っています。
プロジェクトごとにビルドのコマンドが違うので、ビルドフローを洗い出し手作業を排除し、自動化のためにコマンドをこのビルドプロセスで実行しましょう。

=== デプロイ
デプロイでは実行する環境へ合わせてビルドしたコード群を各環境へ配置して、システムを動かせる状態にします。
ここで言う「実行する環境」とは本番環境だけでなく、「ステージ環境」や「統合開発環境」などのことも指します@<fn>{staging}。
つまり、@<strong>{「目的の環境へコードをデプロイし正常にシステムが動く環境を提供するプロセス」}をここに記述します。
AWS を例にすると、
ステージ環境では、費用削減のためにオートスケーリングの台数を 1 台かつダウンタイム発生しても問題ないので単にインスタンスを入れ替えるデプロイ方法を定義する。
本番環境では、オートスケーリング 5 台でダウンタイムを発生させたくないのでローリングアップデート方式でデプロイする。
といった感じで環境に合わせたデプロイプロセスをここで定義します。


このデプロイプロセスで重要なことは、目的の環境へデプロイする際は本番もステージも同じ一つ前のビルドプロセスで作成されたコード群を使ってデプロイしなければならないことです。
すなわち、ビルド 1 コード群に対して複数のデプロイ先を定義できるようにプロセスを作る必要があります。
なぜ同じビルドされたコード群を使わなければならないかというと、ステージと本番のコード群の同一性を担保するためです。
ステージと本番で違うビルドプロセスで作成されたコード群をステージへデプロイし、システムテストをしてもそれはステージ用にビルドされたコード群をテストしたのであって本番用のビルドされたコード群と全く同一であるという保証は厳密にはできません。
このビルドによる環境の差を防ぐために同一ビルドプロセスでビルドを行う必要があります。


複数のデプロイ先を定義するために重要なものが@<strong>{「環境変数」}です。
デプロイの自動化プロセスをうまく回すためにはこの環境変数が重要になります。
ビルドプロセスでは環境に依存したコードを含めずにビルドを行い、デプロイプロセス時に環境変数によってデプロイ先を分離することができます。

//footnote[staging][プロダクトや企業の伝統、開発体制によって呼び方が変わるので言葉の定義はあえてしません。]

== 無料で使える CI サービス
=== GitLabRunner
 GitLabRunner は コードレポジトリサービスを提供している GitLab の CI サービスです。
GitLabRunner は GitLab 公式がメンテナンスしている CI を実行するサーバ「Shared Runner」を提供しています。 
OSS 開発者の場合は無料で「Shared Runner」を利用できます。
また、プライベートレポジトリの場合はグループ毎に 月 2000 時間まで利用できます。

オンプレミスで GitLab を運用しているプロジェクトのために GitLabRunner が実行できるパッケージを各 Linux ディストリビューションで提供しています。
社内のセキュリティポリシーでパブリックなサーバにソースコードをおいてはいけない場合はこの GitLabRunner のパッケージをサーバにインストールしてオンプレミスで CI を実行することもできます。


==== gitlab-ci.yml で CI プロセスを記述する
 「Shared Runner」を利用する場合 プロジェクトフォルダに「gitlab-ci.yml」を追加することですぐに CI のプロセスが実行できるようになります。
「gitlab-ci.yml」は CI プロセスを定義する yml ファイルです。
GitLabRunner はレポジトリに置かれている gitlab-ci.yml のファイルの中を解析し、ファイルに定義されている命令通りにプロセスを実行します。



=== CircleCI
 「GitLabRunner」とは違いどんなレポジトリサービスでも CI を実施できるのが CircleCI です。
GitHub などのレポジトリサービスと連携させることで CircleCI が提供するクラウドサーバ上で、
ビルドやテスト、デプロイまで行うことができるサービスです。

他にも TravisCI や Jenkins など様々な CI サービスがありますので、プロジェクトにあった CI ツールを選択して見てください。

== AWSが提供する CI/CD サービス
AWS にも CI/CD サービスが提供されています。

=== AWS CodeBuild
AWS CodeBuild は クラウド上で実行できるビルド環境を完全マネージドでカスタマイズできるビルドサービスです。
ビルド用のサーバやソフトウェアの設定、実行環境はすべて AWS が管理しユーザはサーバを気にせずビルドスクリプトだけに集中できます。
また、Docker ベースで実行環境を作成できるため、CodeBuild が用意していない実行環境を利用したい場合は自分の Docker イメージ上でビルド環境をカスタマイズすることもできます。
Code Build がデフォルトで提供している実行環境は下記のとおりです。

・android 28	
・Docker 18  
・dotnet 2.2  	
・Golang 1.12  	
・NodeJS 8、10  	
・java openjdk8、openjdk11  
・php 7.3  
・python 3.7  
・ruby 2.6  

Docker がデフォルトで提供されているので提供されていないランタイムは Docker on Docker を利用して自分で用意した Docker イメージでビルド内容をカスタマイズしましょう。
また、CodeBuild では Docker 上でスクリプトが実行できるためビルドだけではなく CI として利用することもできます。
CircleCI や GitLabRunner を使わず AWS だけで完結したい場合は CI の Unit Test や静的解析のコマンドを CodeBuild 上で実行するといった使い方もできるので覚えておきましょう。


=== AWS CodeDeploy
AWS CodeDeploy は AWS のコンピューティングサービス（Amazon EC2、AWS Fargate、AWS Lambda）へのデプロイを自動化できる完全マネージドサービスです。
デプロイ対象ファイルの取得元として S3 または GitHub が選択できます。
またデプロイ先が EC2 の場合 は Tag や AutoScaling グループを選択できるので、複数サーバにデプロイすることも可能です。
更に、複数サーバの場合はどのようにデプロイを実行するかも指定できます。

既存のプロジェクトで CI を GitLab Runner や CircleCI などを利用している場合 AWS 環境へデプロイする際にこの CodeDeploy を組み合わせて使う場合がよくあります。


=== AWS CodePipeline
AWS CodePipeline は一連の CI/CD のワークフローを定義し、デプロイメントパイプライン（パイプライン）を完全マネジメントで作成できるサービスです。
デプロイメントパイプラインとはソースコードからビルド、テスト、デプロイなど CI/CD の各ジョブを自動化したプロセスのことです。
多くのプロジェクトではこのパイプラインが異なると思いますが AWS CodePipeline を利用することでプロジェクトごとのパイプラインを一元管理し、
他のプロジェクトでも再配布可能な形で管理することができます。
これによっていわゆるデプロイ職人と呼ばれる、デプロイの属人化を防ぐとともにデプロイの標準化とパイプラインのバックアップを AWS 上で行うことができます。

== 開発を楽にする CI 環境の作り方
この項では、実際の本番構成を想定した、CI 環境の例を説明します。

=== GitLabRunner + AWS クラウドサーバ 環境下での CI の例
GitLabRunner を使った CI 環境の例を紹介します。
GitLabRunner を AWS で利用する場合最終デリバリー先は S3 バケットとすることが多いです。
GitLabRunner は CD として AWS サービスを操作することができないので S3 バケットにデリバリーした後、AWS CodeDeploy サービスなどを利用して
S3 バケットから各 AWS クラウドサービスにデプロイする CI/CD 環境を作成することがよくあります。
今回も同様に S3 バケットにデリバリーすることろまで GitLabRunner で行います。

次がサンプルの gitlab-ci.yml ファイルの内容です(@<list>{gitlab})。
npm で管理されている javascript プロジェクトを利用します。
ビルドしたコードを aws cli によって s3 へデリバリーするサンプルプロジェクトです。

//listnum[gitlab][gitlab-ci.yml][yaml]{
.lint_template: &lint_definition
  image: node:8.15.1-alpine
  cache:
    key: "$CI_COMMIT_REF_NAME"
    untracked: true
    paths:
      - app/node_modules/
      - app/dist/
  before_script:
    - cd app
    - apk add --no-cache git -q
    - npm install --silent

.deploy_template: &deploy_definition
  image: python:3.7-alpine
  cache:
    key: "$CI_COMMIT_REF_NAME"
    untracked: true
    paths:
      - app/node_modules/
      - app/dist/
  before_script:
    - cd app
    - apk update
    - pip install awscli --quiet

stages:
  - eslint
  - test
  - build
  - deploy

eslint:
  <<: *lint_definition
  stage: eslint
  only:
    - merge_requests
  script:
    - npx eslint ./app/**/*.js

unittest:
  <<: *lint_definition
  stage: test
  only:
    - merge_requests
  script:
    - npm run test

build:
  <<: *lint_definition
  stage: build
  only:
    - master
  script:
    - npm run prod

deploy:
  <<: *deploy_definition
  stage: deploy
  only:
    - master
  script:
    - aws s3 cp ./dist/ s3://prod-bucket/dist --recursive --acl public-read
//}

==== テンプレート
.lint_template や .deploy_template は各 job で利用する共通の処理をテンプレート化することができます。
これは gitLabRunner の機能ではなく yaml の機能で、エイリアスを定義しておくと任意の場所に yaml の記述をマージすることができます。
各 job が Docker イメージを使いまわしたり同じモジュールを使います場合は最初にテンプレートを定義すると便利になります。

==== image 
job を実行するための Docker イメージを指定します。
各 job 毎にイメージを定義することができます。
job 毎に同じイメージを利用する場合は template をうまく利用して Docker イメージを使い回す事もできます。

==== cache 
cache は各 job 毎のキャッシュです。次のジョブに作成したコンテンツを引き渡したい場合にこのキャッシュを利用することができます。
指定したディレクトリ配下のコンテンツが次のジョブに引き継がれますので、ビルドしたコードや、各ジョブで必要になるプロジェクトの展開したパッケージのソースコードなどをキャッシュで定義します。

==== before_script 
before_script はこのテンプレートが実行される前に実行するスクリプトを定義できます。
Docker 公式イメージだけでは足りないモジュールをインストールしたり、カスタムスクリプトを実行させたりユーザが自由に定義できます。

==== stages 
stages では各 job をどのように実行していくかというパイプラインを定義します。
job の名前は任意の名前を利用することができます。
パイプラインは stages で定義されている job を上から順番に実行していきます。

==== only 
only では job を実行したい条件を指定できます。
例えばブランチ名やマージリクエスト時、タグの追加時、ブランチを削除したときなどが指定できます。


==== eslint
eslint では静的解析を実行する job を定義しています。
gitLabRunner はカレントディレクトリにブランチのソースコードを配置します。
したがって相対パスで実行したいディレクトリを指定して npx コマンドで eslint を実行します。
実行する Docker イメージは「<<: *lint_definition」を使ってテンプレートをマージさせています。
また only で marge_request の条件がついているのでマーリリクエスト時にのみしか実行されないジョブになります。

==== unittest
unittest では Unit テストを実行する job を定義しています。
eslint の job 同様です。
プロジェクトで利用している Unit テストツールのコマンドを実行します。
実行結果をメッセージサービスに通知しても良いですし、GitLabRunner 上で結果を閲覧することも可能です。

==== build
build では javascript のビルドを実行する job を定義しています。
npm run prod で本番用のビルドコマンドを叩いてビルドを実行しています。

==== deploy
deploy では aws cli を利用して s3 バケットへビルドしたソースコード群をデリバリーする job を定義しています。
本番用の S3 バケットへビルドした静的ファイル群をデリバリーします。
job 名は deploy となっていますが job 名は任意の名前をつけることができます。

デリバリーの job の実行完了を持って、GitLabRunner としての CI の job が完了します。
S3 へデリバリーされたソースコードは CD として次のサービスに任せることが一般的です。
AWS であれば CodeBuild や CodeDeploy を利用してビルド後本番サーバにデプロイしたりします。
次の項からは CI/CD の CD について見ていきましょう。

== 特徴を知って使い分けるデプロイパターン
最近のプロジェクトでは、デプロイ時に無停止を要求されるプロジェクトも多くあります。
デプロイ時の障害やアップデートの影響を最小限に抑えるためのデプロイパターンと呼ばれるデプロイの方法がいくつかあるので紹介します。

=== ローリングアップデート
ローリングアップデートとは、本番インスタンスを最新バージョンのインスタンスと徐々に入れ替えていくアップデートの方法です。
次の図のようにアップデートができます@<img>{rolling}。
//image[rolling][ローリングアップデート][scale=0.8]{
//}
新しいバージョンのインスタンスを徐々に入れ替えていくことで最新バージョンのデプロイの失敗リスクを最小限に抑えつつアップデートすることができます。
最終的には全てのインスタンスが最新バージョンに入れ替わりますが、途中古いバージョンと新しいバージョンが混在することになりますので
アップデート内容は新・旧両方動作するようなアップデート内容でないとこの方法でアップデートできないことに注意しましょう。

=== ブルー・グリーンデプロイ
ブルー・グリーンデプロイとは、最新バージョンがデプロイされている環境を本番と完全に同様の構成で作成し
DNSのレコードやロードバランサーのルーティングを古い環境から新しい環境へと切り替えることでアップデートを行う方法です@<img>{blue-green}。

//image[blue-green][ローリングアップデート][scale=0.8]{
//}

このアップデートは、DNSのレコード切り替えによって簡単に古いバージョンと新しいバージョンが切り替えられるので問題があった場合はすぐに古いバージョンへと切り戻しが行なえます。
しかし、完全に新しいバージョンへ切り替えてしまうので、事前の動作チェックをしっかりと行う必要があります。
ローリングアップデートとは異なり、新しいバージョンで問題があった場合はロールバックするまでは不具合のある新バージョンでしばらく動作するので、
アプリケーションに影響があることを理解しておきましょう。

== 最速で作る CI/CD パイプライン CodeStar
CodeStar とは AWS 上に CI/CD パイプラインを簡単に構築できるサービスです。
AWS では CI/CD サービスとして下記の4つのサービス（俗に言う Code4 兄弟）を提供しています。

・CodeBuild  

・CodeDeploy  

・CodeCommit  

・CodePipline   

しかしサービスが増えるうちに自力で設定するのが大変であったり、4つのサービスコンソールを行き来するのが煩わしい、一つの箇所で管理したいといった要望
が増えてきたのを受けて新しく CodeStar と呼ばれるサービスがリリースされました。

CodeStar はアプリケーションのコーディングから CI/CD パイプラインをプロジェクトテンプレートの中から選択し、数分で設定することができます。
Code4 兄弟の知識がなくても AWS が自動でビルドからデプロイの設定を行ってくれるので、初心者にとっては簡単に CI/CD を始めることができます。

CodeStar の作成手順です。

まず AWS コンソールから 「CodeStar」を検索し「新規プロジェクトの開始」を押下します（@<img>{codestar-1}）。
//image[codestar-1][codestar-1][scale=0.8]{
//}

すると、プロジェクトテンプレートの選択画面が表示されます（@<img>{codestar-2}）。
CodeStar では数十種類のプロジェクトテンプレートから簡単にアプリケーションと CI/CD 環境を構築することができます。
今回は Laravel (Amazon EC2) を選択します。
//image[codestar-2][codestar-2][scale=0.8]{
//}

プロジェクト作成画面では git のレポジトリを選択します。
今回は GitHub を選択し、「GitHubに接続」を押下します（@<img>{codestar-3}）。
//image[codestar-3][codestar-3][scale=0.8]{
//}

別ウィンドウで CodeStar と GitHub の連携認証が求められるので認証を行います。
「AWS CodeStar は GitHub に接続されました」と表示されると GitHub と連携され、レポジトリを作成する画面が表示されます（@<img>{codestar-4}）。
レポジトリ名を確認し、問題なければ「次へ」を押下します。
//image[codestar-4][codestar-4][scale=0.8]{
//}

プロジェクト詳細の確認では、CodeStar が作成する CI/CD パイプラインが表示されます（@<img>{codestar-5}）。
ここで EC2 のスペックを編集することができますので任意で変更します。
問題なければ「プロジェクトを作成する」を押下します。
//image[codestar-5][codestar-5][scale=0.8]{
//}

CodeStar に初めてアクセスする場合は CodeStar の管理コンソール上で表示される名前とメールを登録する必要があります（@<img>{codestar-6}）。
入力したら「次へ」を押下します。
//image[codestar-6][初回アクセス時の登録画面][scale=0.8]{
//}

少し待つと CodeStar は自動で GitHub に初期プロジェクトのテンプレート（@<img>{codestar-7}）と CI/CD 環境と CodeStar の管理画面をセットアップしてくれます。
//image[codestar-7][GitHub 初期プロジェクト][scale=0.8]{
//}

CodeStar の管理画面ではプロジェクトごとに CI/CD の進行状況や成功・失敗状況、 プロジェクトの CI/CD 用の Wiki の編集、サーバの情報などを管理することができます@<img>{codestar-9}。
また Code4兄弟の CI/CD 状況を見るためのメニューも用意されているので CodeStar 管理画面内で行いたい操作がすべて完結できるのが特徴です。
//image[codestar-9][CodeStar 管理画面][scale=0.8]{
//}

最後に、作成した GitHub のレポジトリに対してコードを変更して push してみましょう。
すると、管理画面では CI/CD パイプラインが「Source」「Build」「Deploy」の順で進行していく様子が見れます。
Deploy が完了するとインスタンスに新しいバージョンのソースコードが反映されます。

これで初めての CI/CD 環境を簡単に構築することができました。
CodeStar で CI/CD をカスタマイズする場合はプロジェクトソースコードに追加されている「buildspec.yml」と「appspec.yml」を修正します。
詳細は解説を省きますが「buildspec.yml」ではプロジェクトのビルド仕様をコマンドで記述していきます。
CodeBuild はこの buildspec.yml ファイルをもとにビルドを実行します。
「appspec.yml」はプロジェクトのデプロイ仕様を記述します。
ソースコードをどのドキュメントルートに配置するかやサービスの再起動、デプロイ時の安全なサービスの停止コマンドなどを定義します。
CodeDeploy はこの appspec.yml ファイルをもとにデプロイを実行します。
CodeBuild や CodeDeploy は様々なプロジェクトに対応できるためにたくさんの設定項目を定義することができます。
AWS の CI/CD 環境になれたら AWS 公式ページの仕様書@<fn>{codedeploy}@<fn>{codedeploy}を読んでプロジェクトにあった CI/CD 環境を構築していきましょう。

//footnote[codebuild][codebuild　https://docs.aws.amazon.com/ja_jp/codebuild/latest/userguide/welcome.html]
//footnote[codedeploy][CodeDeploy　https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/welcome.html]



== まとめ
いかがでしたでしょうか。最初 CI/CD という言葉だけでは理解が及ばなかった部分をこの章を通して少しでも理解のお役に立てていただけると幸いです。
現在のスピーディーなアジャイル開発スタイルではほぼ必須となっている CI/CD 。
エンジニアは誰もが理解し使いこなせるようになっていれば、自分が所属しているプロジェクトの開発が少しでも楽になっていくかと思います。
もしそうなっていないなら少しづつでいいですのでプロジェクトに導入してみてください。
もしかしたら提案するだけだと色々言われて却下されるかもしれません。
開発環境を楽にするために自分が主体的になって動いてみてください。
きっと努力が報われ素晴らしいプロジェクト＆プロダクトになると思います。
